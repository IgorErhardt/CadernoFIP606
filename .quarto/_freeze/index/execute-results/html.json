{
  "hash": "5398068fd319fb7edc0bdb9254a6b993",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Caderno FIP606\"\nwarning: False\n---\n\n\n\n\n# 1. Operações Básicas\n\n## 1.1 Atribuição e Variáveis\n\n-   **Operadores de atribuição**: `<-` é o mais usado, embora `=` funcione.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- 10        # atribui 10 a x\n    y = 5          # atribui 5 a y\n    ```\n    :::\n\n\n\n\n-   **Nomes de variáveis**: usam letras, números, `.` e `_`, mas não podem começar com número ou ponto seguido de número. Exemplo:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pontuacao_aluno <- 90\n    .variavel_oculta <- 1   # válido, mas desaconselhado\n    ```\n    :::\n\n\n\n\n## 1.2 Vetores e Operações Elementares\n\n-   **Criar vetores**: `c()`, `:` e `seq()`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nums <- c(1, 2, 3, 4)\n    seq_vezes <- seq(from=0, to=1, length.out=5)\n    intervalo <- 1:5\n    ```\n    :::\n\n\n\n\n-   **Operações aritméticas**:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a <- c(1,2,3); b <- c(4,5,6)\n    a + b   # c(5,7,9)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5 7 9\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    a * 2   # c(2,4,6)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2 4 6\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   **Regra de reciclagem**: vetores menores se repetem para igualar o tamanho:\n\n    ``` r\n    c(1,2) + c(1,2,3,4)  # c(2,4,4,6)\n    ```\n\n## 1.3 Operadores Lógicos e de Comparação\n\n-   **Comparação**: `<`, `>`, `<=`, `>=`, `==`, `!=`.\n\n-   **Lógicos**: `&` (E elemento a elemento), `|` (OU elemento a elemento), `!` (NÃO). Use `&&`, `||` para condição única.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(1, 2, 3)\n    x > 1       # c(FALSE, TRUE, TRUE)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] FALSE  TRUE  TRUE\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    x >= 2 & x <= 3   # c(FALSE, TRUE, TRUE)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] FALSE  TRUE  TRUE\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n## 1.4 Valores Ausentes e Especiais\n\n-   `NA`: falta de dado; `NaN`: resultado indefinido; `Inf`/`-Inf`: infinito.\n\n-   Funções: `is.na()`, `is.nan()`, `is.finite()`, `is.infinite()`.\n\n-   Tratamento de NAs:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dados <- c(1, NA, 3)\n    dados <- na.omit(dados)\n    mean(dados, na.rm=TRUE)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n# 2. Estruturas de Dados\n\n## 2.1 Vetores Atômicos e Coerção\n\n-   Tipos: *numeric*, *integer*, *character*, *logical*, *complex*, *raw*.\n\n-   Hierarquia de coerção: *logical -\\> integer -\\> numeric -\\> complex -\\> character*.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    misto <- c(TRUE, 2, \"a\")  # convertido para character\n    ```\n    :::\n\n\n\n\n## 2.2 Fatores\n\n-   Dados categóricos com níveis fixos.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    f <- factor(c(\"baixo\",\"médio\",\"alto\"), levels=c(\"baixo\",\"médio\",\"alto\"))\n    levels(f)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"baixo\" \"médio\" \"alto\" \n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    table(f)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    f\n    baixo médio  alto \n        1     1     1 \n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   Converter: `as.character(f)`, `as.numeric(f)`.\n\n## 2.3 Datas e Horários\n\n-   **Date**: `as.Date(\"2025-07-09\")`, formatos `%Y-%m-%d`.\n\n-   **POSIXct/POSIXlt**: data-hora.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    d <- as.Date(\"2025-07-09\", \"%Y-%m-%d\")\n    dt <- as.POSIXct(\"2025-07-09 15:00:00\")\n    ```\n    :::\n\n\n\n\n-   Pacote **lubridate**:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(lubridate)\n    ymd(\"20250709\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"2025-07-09\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    mdy(\"07-09-2025\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"2025-07-09\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    hms(\"15:00:00\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"15H 0M 0S\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n## 2.4 Listas\n\n-   Coleções heterogêneas ordenadas.\n\n-   Acesso: `[[ ]]` ou `$`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    lst <- list(nome=\"Igor\", notas=c(90,95), aprovado=TRUE)\n    lst[[\"notas\"]]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 90 95\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    lst$aprovado\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] TRUE\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n## 2.5 Data Frames e Tibbles\n\n-   Tabelas bidimensionais heterogêneas.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df <- data.frame(id=1:3, nota=c(10,20,15), stringsAsFactors=FALSE)\n    ```\n    :::\n\n\n\n\n-   **Tibbles**:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(tibble)\n    tb <- tibble(id=1:3, nota=c(10,20,15))\n    ```\n    :::\n\n\n\n\n-   Inspeção: `str()`, `head()`, `glimpse()`.\n\n## 2.6 Matrizes e Arrays\n\n-   **Matriz**: bidimensional homogênea (`matrix()`).\n-   **Array**: estruturas com múltiplas dimensões (`array()`).\n-   Acesso: `[linha, coluna]` ou `[i,j,k]`.\n\n# 3. Importação e Manipulação de Dados\n\n## 3.1 Leitura de Dados\n\n-   CSV: `read.csv()`, `read_csv()` (readr).\n-   Excel: `readxl::read_excel()`.\n-   Alta performance: `data.table::fread()`, `vroom::vroom()`.\n\n## 3.2 Princípios de Dados Tidy\n\n-   Cada variável em uma coluna, cada observação em uma linha.\n-   **tidyr**:\n    -   `pivot_longer()`, `pivot_wider()`\n    -   `separate()`, `unite()`\n\n## 3.3 Workflow dplyr\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\ndf %>%\n  filter(nota > 10) %>%\n  select(id, nota) %>%\n  mutate(pct = nota / max(nota)) %>%\n  arrange(desc(pct))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id nota  pct\n1  2   20 1.00\n2  3   15 0.75\n```\n\n\n:::\n:::\n\n\n\n\n-   Operações agrupadas:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df %>% group_by(id) %>% summarise(nota_media = mean(nota))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    # A tibble: 3 × 2\n         id nota_media\n      <int>      <dbl>\n    1     1         10\n    2     2         20\n    3     3         15\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n## 3.4 Conjuntos de Dados Embutidos\n\nO R disponibiliza diversos conjuntos de dados (datasets) prontos para uso, úteis para exemplos e testes:\n\n-   **iris**: medidas de sépalas e pétalas de três espécies de íris.\n-   **mtcars**: características de desempenho de diversos modelos de automóveis.\n-   **airquality**: medições diárias de qualidade do ar em Nova York.\n\nPara listar todos os datasets embutidos, use: data()\n\nPara carregar explicitamente um dataset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(iris)\nhead(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n\n\n:::\n:::\n\n\n\n\n# 4. Gráficos com ggplot2\n\n## 4.1 Componentes Básicos\n\n-   **ggplot(dados, aes(...))**: define dados e mapeamentos.\n-   Camadas **geom**: `geom_point()`, `geom_line()`, `geom_bar()`, `geom_histogram()`.\n-   Facetas: `facet_wrap()`, `facet_grid()`.\n\n## 4.2 Customização\n\n-   Temas: `theme_minimal()`, `theme_classic()`.\n-   Rótulos: `labs(title=, subtitle=, x=, y=, caption=)`.\n-   Legendas: `theme(legend.position = \"bottom\")`.\n\n## 4.3 Exemplos\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(mtcars, aes(x=wt, y=mpg, color=factor(cyl))) +\n  geom_point(size=3) +\n  facet_wrap(~cyl) +\n  labs(\n    title = \"MPG vs Peso por Cilindro\",\n    x = \"Peso (1000 lbs)\",\n    y = \"Milhas por Galão\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Histograma com densidade\nggplot(iris, aes(x=Sepal.Length, fill=Species)) +\n  geom_histogram(alpha=0.6, position=\"identity\", bins=30) +\n  geom_density(alpha=0.4) +\n  labs(title=\"Distribuição do Comprimento da Sépala\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n\n# 5. Modelagem Estatística Básica\n\n## 5.1 Modelos Lineares (lm)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodelo <- lm(nota ~ id + I(id^2), data=df)\nsummary(modelo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = nota ~ id + I(id^2), data = df)\n\nResiduals:\nALL 3 residuals are 0: no residual degrees of freedom!\n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)    -15.0        NaN     NaN      NaN\nid              32.5        NaN     NaN      NaN\nI(id^2)         -7.5        NaN     NaN      NaN\n\nResidual standard error: NaN on 0 degrees of freedom\nMultiple R-squared:      1,\tAdjusted R-squared:    NaN \nF-statistic:   NaN on 2 and 0 DF,  p-value: NA\n```\n\n\n:::\n:::\n\n\n\n\n-   Interpretar coeficientes, p-valores, R² e resíduos.\n-   Diagnósticos: `plot(modelo)`.\n\n## 5.2 Modelos Lineares Generalizados (glm)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$aprovado <- df$nota >= 12\nglm_bin <- glm(aprovado ~ nota, family = binomial(link = \"logit\"), data = df)\nsummary(glm_bin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = aprovado ~ nota, family = binomial(link = \"logit\"), \n    data = df)\n\nCoefficients:\n              Estimate Std. Error z value Pr(>|z|)\n(Intercept)   -116.146 252537.088       0        1\nnota             9.269  18831.344       0        1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 3.8191e+00  on 2  degrees of freedom\nResidual deviance: 3.5965e-10  on 1  degrees of freedom\nAIC: 4\n\nNumber of Fisher Scoring iterations: 23\n```\n\n\n:::\n:::\n\n\n\n\n-   Familias: `binomial`, `poisson`, `Gamma`.\n-   Links: `logit`, `log`, `identity`.\n\n## 5.3 Avaliação de Modelos\n\n-   **Análise de resíduos**: `plot(modelo)`, **DHARMa** para GLMs.\n-   **Critérios de informação**: `AIC(modelo)`, `BIC(modelo)`.\n-   **Validação cruzada**: `caret::train()` ou **tidymodels**.\n\n# 6. Estruturas de Controle: Agrupamento, Loops e Condicionais\n\n## 6.1 Agrupamento com split, lapply, by e tapply\n\n-   **split()**: divide dados em grupos:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    iris_split <- split(iris, iris$Species)\n    ```\n    :::\n\n\n\n\n-   **lapply()**: aplica função a cada elemento:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    media_sepala <- lapply(iris_split, function(df) mean(df$Sepal.Length))\n    ```\n    :::\n\n\n\n\n-   **by()**: aplica função por grupos em data frame:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    by(data = iris$Sepal.Length, INDICES = iris$Species, FUN = mean)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    iris$Species: setosa\n    [1] 5.006\n    ------------------------------------------------------------ \n    iris$Species: versicolor\n    [1] 5.936\n    ------------------------------------------------------------ \n    iris$Species: virginica\n    [1] 6.588\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   **tapply()**: aplica função a subsets de um vetor:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    tapply(iris$Sepal.Length, iris$Species, mean)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n        setosa versicolor  virginica \n         5.006      5.936      6.588 \n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n## 6.2 Loops\n\n-   **for**:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    for (i in 1:5) {\n      print(i^2)\n    }\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    [1] 4\n    [1] 9\n    [1] 16\n    [1] 25\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   **while**:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    cont <- 1\n    while (cont <= 5) {\n      print(cont)\n      cont <- cont + 1\n    }\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    [1] 2\n    [1] 3\n    [1] 4\n    [1] 5\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   **repeat** (até break):\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    repeat {\n      val <- runif(1)\n      if (val > 0.9) {\n        print(val)\n        break\n      }\n    }\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 0.9491219\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n## 6.3 Condicionais\n\n-   **if / else**:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- -3\n    if (x > 0) {\n      message(\"Positivo\")\n    } else if (x == 0) {\n      message(\"Zero\")\n    } else {\n      message(\"Negativo\")\n    }\n    ```\n    :::\n\n\n\n\n-   **ifelse()** (vetorizado):\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(-1, 0, 1)\n    resultado <- ifelse(x > 0, \"Positivo\", \"Não positivo\")\n    resultado\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Não positivo\" \"Não positivo\" \"Positivo\"    \n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n## 6.4 Boas Práticas\n\n-   Prefira funções vetorizadas (`apply`, `lapply`, `sapply`) em vez de loops explícitos.\n-   Use nomes descritivos e indentação consistente.\n-   Evite aninhamentos profundos; crie funções para lógicas complexas.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}